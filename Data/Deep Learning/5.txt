Chapter 5
Machine Learning Basics
Deep learning is a specific kind of machine learning. In order to understand
deep learning well, one must have a solid understanding of the basic principles of
machine learning. This chapter provides a brief course in the most important general
principles that will be applied throughout the rest of the book. Novice readers or
those who want a wider perspective are encouraged to consider machine learning
textbooks with a more comprehensive coverage of the fundamentals, such as Murphy
(2012) or Bishop (2006). If you are already familiar with machine learning basics,
feel free to skip ahead to section 5.11. That section covers some perspectives
on traditional machine learning techniques that have strongly influenced the
development of deep learning algorithms. We begin with a definition of what a learning algorithm is, and present an
example: the linear regression algorithm. We then proceed to describe how the
challenge of fitting the training data differs from the challenge of finding patterns
that generalize to new data. Most machine learning algorithms have settings
called hyperparameters that must be determined external to the learning algorithm
itself; we discuss how to set these using additional data. Machine learning is
essentially a form of applied statistics with increased emphasis on the use of
computers to statistically estimate complicated functions and a decreased emphasis
on proving confidence intervals around these functions; we therefore present the
two central approaches to statistics: frequentist estimators and Bayesian inference.
Most machine learning algorithms can be divided into the categories of supervised
learning and unsupervised learning; we describe these categories and give some
examples of simple learning algorithms from each category. Most deep learning
algorithms are based on an optimization algorithm called stochastic gradient
descent. We describe how to combine various algorithm components such as
an optimization algorithm, a cost function, a model, and a dataset to build a
machine learning algorithm. Finally, in section 5.11, we describe some of the
factors that have limited the ability of traditional machine learning to generalize.
These challenges have motivated the development of deep learning algorithms that
overcome these obstacles.
5.1 Learning Algorithms
A machine learning algorithm is an algorithm that is able to learn from data. But
what do we mean by learning? Mitchell (1997) provides the definition {\textquotedblleft}A computer
program is said to learn from experience E with respect to some class of tasks T
and performance measure P, if its performance at tasks in T, as measured by P,
improves with experience E.{\textquotedblright} One can imagine a very wide variety of experiences
E, tasks T, and performance measures P, and we do not make any attempt in this
book to provide a formal definition of what may be used for each of these entities. Instead, the following sections provide intuitive descriptions and examples of the
different kinds of tasks, performance measures and experiences that can be used
to construct machine learning algorithms.
5.1.1 The Task, T
Machine learning allows us to tackle tasks that are too difficult to solve with
fixed programs written and designed by human beings. From a scientific and
philosophical point of view, machine learning is interesting because developing our
understanding of machine learning entails developing our understanding of the
principles that underlie intelligence.
In this relatively formal definition of the word {\textquotedblleft}task,{\textquotedblright} the process of learning
itself is not the task. Learning is our means of attaining the ability to perform the
task. For example, if we want a robot to be able to walk, then walking is the task. We could program the robot to learn to walk, or we could attempt to directly write
a program that specifies how to walk manually. Machine learning tasks are usually described in terms of how the machine
learning system should process an example. An example is a collection of features
that have been quantitatively measured from some object or event that we want
the machine learning system to process. We typically represent an example as a
vector x {\in} R
n where each entry xi of the vector is another feature. For example,
the features of an image are usually the values of the pixels in the image.
Many kinds of tasks can be solved with machine learning. Some of the most
common machine learning tasks include the following:
 Classification: In this type of task, the computer program is asked to specify
which of k categories some input belongs to. To solve this task, the learning
algorithm is usually asked to produce a function f : R
n {\textrightarrow} {\{}1, . . . , k{\}}. When
y = f(x), the model assigns an input described by vector x to a category
identified by numeric code y. There are other variants of the classification
task, for example, where f outputs a probability distribution over classes. An example of a classification task is object recognition, where the input
is an image (usually described as a set of pixel brightness values), and the
output is a numeric code identifying the object in the image. For example,
the Willow Garage PR2 robot is able to act as a waiter that can recognize
different kinds of drinks and deliver them to people on command (Goodfellow et al., 2010). Modern object recognition is best accomplished with
deep learning (Krizhevsky et al., 2012; Ioffe and Szegedy, 2015). Object
recognition is the same basic technology that allows computers to recognize
faces (Taigman et al., 2014), which can be used to automatically tag people
in photo collections and allow computers to interact more naturally with
their users.
 Classification with missing inputs: Classification becomes more challenging if the computer program is not guaranteed that every measurement
in its input vector will always be provided. In order to solve the classification
task, the learning algorithm only has to define a single function mapping
from a vector input to a categorical output. When some of the inputs may
be missing, rather than providing a single classification function, the learning
algorithm must learn a set of functions. Each function corresponds to classifying x with a different subset of its inputs missing. This kind of situation
arises frequently in medical diagnosis, because many kinds of medical tests
are expensive or invasive. One way to efficiently define such a large set
of functions is to learn a probability distribution over all of the relevant
variables, then solve the classification task by marginalizing out the missing
variables. With n input variables, we can now obtain all 2
n different classifi- cation functions needed for each possible set of missing inputs, but we only
need to learn a single function describing the joint probability distribution.
See Goodfellow et al. (2013b) for an example of a deep probabilistic model
applied to such a task in this way. Many of the other tasks described in this
section can also be generalized to work with missing inputs; classification
with missing inputs is just one example of what machine learning can do.
 Regression: In this type of task, the computer program is asked to predict a
numerical value given some input. To solve this task, the learning algorithm
is asked to output a function f : R
n {\textrightarrow} R. This type of task is similar to
classification, except that the format of output is different. An example of
a regression task is the prediction of the expected claim amount that an
insured person will make (used to set insurance premiums), or the prediction
of future prices of securities. These kinds of predictions are also used for
algorithmic trading.
 Transcription: In this type of task, the machine learning system is asked
to observe a relatively unstructured representation of some kind of data and
transcribe it into discrete, textual form. For example, in optical character
recognition, the computer program is shown a photograph containing an
image of text and is asked to return this text in the form of a sequence
of characters (e.g., in ASCII or Unicode format). Google Street View uses
deep learning to process address numbers in this way (Goodfellow et al., 2014d). Another example is speech recognition, where the computer program
is provided an audio waveform and emits a sequence of characters or word
ID codes describing the words that were spoken in the audio recording. Deep
learning is a crucial component of modern speech recognition systems used
at major companies including Microsoft, IBM and Google (Hinton et al., 2012b).
 Machine translation: In a machine translation task, the input already
consists of a sequence of symbols in some language, and the computer program
must convert this into a sequence of symbols in another language. This is
commonly applied to natural languages, such as translating from English to
French. Deep learning has recently begun to have an important impact on
this kind of task (Sutskever et al., 2014; Bahdanau et al., 2015).
 Structured output: Structured output tasks involve any task where the
output is a vector (or other data structure containing multiple values) with
important relationships between the different elements. This is a broad
category, and subsumes the transcription and translation tasks described
above, but also many other tasks. One example is parsing{\textemdash}mapping a
natural language sentence into a tree that describes its grammatical structure
and tagging nodes of the trees as being verbs, nouns, or adverbs, and so on.
See Collobert (2011) for an example of deep learning applied to a parsing
task. Another example is pixel-wise segmentation of images, where the
computer program assigns every pixel in an image to a specific category. For
example, deep learning can be used to annotate the locations of roads in
aerial photographs (Mnih and Hinton, 2010). The output need not have its
form mirror the structure of the input as closely as in these annotation-style
tasks. For example, in image captioning, the computer program observes an
image and outputs a natural language sentence describing the image (Kiros
et al., 2014a,b; Mao et al., 2015; Vinyals et al., 2015b; Donahue et al., 2014;
Karpathy and Li, 2015; Fang et al., 2015; Xu et al., 2015). These tasks are
called structured output tasks because the program must output several
values that are all tightly inter-related. For example, the words produced by
an image captioning program must form a valid sentence.
 Anomaly detection: In this type of task, the computer program sifts
through a set of events or objects, and flags some of them as being unusual
or atypical. An example of an anomaly detection task is credit card fraud
detection. By modeling your purchasing habits, a credit card company can
detect misuse of your cards. If a thief steals your credit card or credit card
information, the thief`s purchases will often come from a different probability
distribution over purchase types than your own. The credit card company
can prevent fraud by placing a hold on an account as soon as that card has
been used for an uncharacteristic purchase. See Chandola et al. (2009) for a
survey of anomaly detection methods.  Synthesis and sampling: In this type of task, the machine learning algorithm is asked to generate new examples that are similar to those in the
training data. Synthesis and sampling via machine learning can be useful
for media applications where it can be expensive or boring for an artist to
generate large volumes of content by hand. For example, video games can
automatically generate textures for large objects or landscapes, rather than
requiring an artist to manually label each pixel (Luo et al., 2013). In some
cases, we want the sampling or synthesis procedure to generate some specific
kind of output given the input. For example, in a speech synthesis task, we
provide a written sentence and ask the program to emit an audio waveform
containing a spoken version of that sentence. This is a kind of structured
output task, but with the added qualification that there is no single correct
output for each input, and we explicitly desire a large amount of variation in
the output, in order for the output to seem more natural and realistic.
 Imputation of missing values: In this type of task, the machine learning
algorithm is given a new example x {\in} R
n
, but with some entries xi of x
missing. The algorithm must provide a prediction of the values of the missing
entries.
 Denoising: In this type of task, the machine learning algorithm is given in
input a corrupted example x{\textasciitilde} {\in} Rn obtained by an unknown corruption process
from a clean example x {\in} Rn
. The learner must predict the clean example
x from its corrupted version x{\textasciitilde}, or more generally predict the conditional
probability distribution p(x | x{\textasciitilde}).
 Density estimation or probability mass function estimation: In
the density estimation problem, the machine learning algorithm is asked
to learn a function pmodel : R n {\textrightarrow} R, where pmodel(x) can be interpreted
as a probability density function (if x is continuous) or a probability mass
function (if x is discrete) on the space that the examples were drawn from.
To do such a task well (we will specify exactly what that means when we
discuss performance measures P), the algorithm needs to learn the structure
of the data it has seen. It must know where examples cluster tightly and
where they are unlikely to occur. Most of the tasks described above require
the learning algorithm to at least implicitly capture the structure of the
probability distribution. Density estimation allows us to explicitly capture
that distribution. In principle, we can then perform computations on that
distribution in order to solve the other tasks as well. For example, if we
have performed density estimation to obtain a probability distribution p(x), we can use that distribution to solve the missing value imputation task. If
a value xi is missing and all of the other values, denoted x{-}i, are given,
then we know the distribution over it is given by p(xi | x{-}i). In practice,
density estimation does not always allow us to solve all of these related tasks, because in many cases the required operations on p(x) are computationally
intractable.
Of course, many other tasks and types of tasks are possible. The types of tasks
we list here are intended only to provide examples of what machine learning can
do, not to define a rigid taxonomy of tasks.
5.1.2 The Performance Measure, P
In order to evaluate the abilities of a machine learning algorithm, we must design
a quantitative measure of its performance. Usually this performance measure P is
specific to the task T being carried out by the system.
For tasks such as classification, classification with missing inputs, and transcription, we often measure the accuracy of the model. Accuracy is just the
proportion of examples for which the model produces the correct output. We can
also obtain equivalent information by measuring the error rate, the proportion
of examples for which the model produces an incorrect output. We often refer to
the error rate as the expected 0-1 loss. The 0-1 loss on a particular example is 0
if it is correctly classified and 1 if it is not. For tasks such as density estimation,
it does not make sense to measure accuracy, error rate, or any other kind of 0-1
loss. Instead, we must use a different performance metric that gives the model
a continuous-valued score for each example. The most common approach is to
report the average log-probability the model assigns to some examples. Usually we are interested in how well the machine learning algorithm performs
on data that it has not seen before, since this determines how well it will work when
deployed in the real world. We therefore evaluate these performance measures using
a test set of data that is separate from the data used for training the machine
learning system.
The choice of performance measure may seem straightforward and objective, but it is often difficult to choose a performance measure that corresponds well to
the desired behavior of the system.
In some cases, this is because it is difficult to decide what should be measured. For example, when performing a transcription task, should we measure the accuracy
of the system at transcribing entire sequences, or should we use a more fine-grained
performance measure that gives partial credit for getting some elements of the
sequence correct? When performing a regression task, should we penalize the
system more if it frequently makes medium-sized mistakes or if it rarely makes
very large mistakes? These kinds of design choices depend on the application.
In other cases, we know what quantity we would ideally like to measure, but
measuring it is impractical. For example, this arises frequently in the context of
density estimation. Many of the best probabilistic models represent probability
distributions only implicitly. Computing the actual probability value assigned to
a specific point in space in many such models is intractable. In these cases, one
must design an alternative criterion that still corresponds to the design objectives, or design a good approximation to the desired criterion.
5.1.3 The Experience, E
Machine learning algorithms can be broadly categorized as unsupervised or
supervised by what kind of experience they are allowed to have during the
learning process. Most of the learning algorithms in this book can be understood as being allowed
to experience an entire dataset. A dataset is a collection of many examples, as
defined in section 5.1.1. Sometimes we will also call examples data points. One of the oldest datasets studied by statisticians and machine learning re- searchers is the Iris dataset (Fisher, 1936). It is a collection of measurements of
different parts of 150 iris plants. Each individual plant corresponds to one example.
The features within each example are the measurements of each of the parts of the
plant: the sepal length, sepal width, petal length and petal width. The dataset
also records which species each plant belonged to. Three different species are
represented in the dataset. Unsupervised learning algorithms experience a dataset containing many
features, then learn useful properties of the structure of this dataset. In the context
of deep learning, we usually want to learn the entire probability distribution that
generated a dataset, whether explicitly as in density estimation or implicitly for
tasks like synthesis or denoising. Some other unsupervised learning algorithms
perform other roles, like clustering, which consists of dividing the dataset into
clusters of similar examples. Supervised learning algorithms experience a dataset containing features, but each example is also associated with a label or target. For example, the Iris
dataset is annotated with the species of each iris plant. A supervised learning
algorithm can study the Iris dataset and learn to classify iris plants into three
different species based on their measurements. Roughly speaking, unsupervised learning involves observing several examples
of a random vector x, and attempting to implicitly or explicitly learn the probability distribution p(x), or some interesting properties of that distribution, while
supervised learning involves observing several examples of a random vector x and
an associated value or vector y, and learning to predict y from x, usually by
estimating p(y | x). The term supervised learning originates from the view of
the target y being provided by an instructor or teacher who shows the machine
learning system what to do. In unsupervised learning, there is no instructor or
teacher, and the algorithm must learn to make sense of the data without this guide.
Unsupervised learning and supervised learning are not formally defined terms. The lines between them are often blurred. Many machine learning technologies can
be used to perform both tasks. For example, the chain rule of probability states
that for a vector x {\in} Rn
, the joint distribution can be decomposed as
p(x) =n
i=1
p(xi | x1, . . . , xi{-}1). (5.1)
This decomposition means that we can solve the ostensibly unsupervised problem of
modeling p(x) by splitting it into n supervised learning problems. Alternatively, we
can solve the supervised learning problem of learning p(y | x) by using traditional
unsupervised learning technologies to learn the joint distribution p(x, y) and
inferring
p(y | x) =
p(x, y)

y
 p(x, y
)
. (5.2)
Though unsupervised learning and supervised learning are not completely formal or
distinct concepts, they do help to roughly categorize some of the things we do with
machine learning algorithms. Traditionally, people refer to regression, classification
and structured output problems as supervised learning. Density estimation in
support of other tasks is usually considered unsupervised learning.
Other variants of the learning paradigm are possible. For example, in semisupervised learning, some examples include a supervision target but others do
not. In multi-instance learning, an entire collection of examples is labeled as
containing or not containing an example of a class, but the individual members
of the collection are not labeled. For a recent example of multi-instance learning
with deep models, see Kotzias et al. (2015). Some machine learning algorithms do not just experience a fixed dataset. For
example, reinforcement learning algorithms interact with an environment, so
there is a feedback loop between the learning system and its experiences. Such
algorithms are beyond the scope of this book. Please see Sutton and Barto (1998)
or Bertsekas and Tsitsiklis (1996) for information about reinforcement learning,
and Mnih et al. (2013) for the deep learning approach to reinforcement learning.
Most machine learning algorithms simply experience a dataset. A dataset can
be described in many ways. In all cases, a dataset is a collection of examples, which are in turn collections of features. One common way of describing a dataset is with a design matrix. A design
matrix is a matrix containing a different example in each row. Each column of the
matrix corresponds to a different feature. For instance, the Iris dataset contains
150 examples with four features for each example. This means we can represent
the dataset with a design matrix X {\in} R150{\texttimes}4
, where Xi,1 is the sepal length of
plant i, Xi,2 is the sepal width of plant i, etc. We will describe most of the learning
algorithms in this book in terms of how they operate on design matrix datasets. Of course, to describe a dataset as a design matrix, it must be possible to
describe each example as a vector, and each of these vectors must be the same size.
This is not always possible. For example, if you have a collection of photographs
with different widths and heights, then different photographs will contain different
numbers of pixels, so not all of the photographs may be described with the same
length of vector. Section 9.7 and chapter 10 describe how to handle different
types of such heterogeneous data. In cases like these, rather than describing the
dataset as a matrix with m rows, we will describe it as a set containing m elements:
{\{}x
(1)
, x
(2)
, . . . , x
(m){\}}. This notation does not imply that any two example vectors
x
(i) and x
(j) have the same size.
In the case of supervised learning, the example contains a label or target as
well as a collection of features. For example, if we want to use a learning algorithm
to perform object recognition from photographs, we need to specify which object
appears in each of the photos. We might do this with a numeric code, with 0
signifying a person, 1 signifying a car, 2 signifying a cat, etc. Often when working
with a dataset containing a design matrix of feature observations X, we also
provide a vector of labels y, with yi providing the label for example i. Of course, sometimes the label may be more than just a single number. For
example, if we want to train a speech recognition system to transcribe entire
sentences, then the label for each example sentence is a sequence of words. Just as there is no formal definition of supervised and unsupervised learning,
there is no rigid taxonomy of datasets or experiences. The structures described here
cover most cases, but it is always possible to design new ones for new applications.
5.1.4 Example: Linear Regression
Our definition of a machine learning algorithm as an algorithm that is capable
of improving a computer program`s performance at some task via experience is
somewhat abstract. To make this more concrete, we present an example of a
simple machine learning algorithm: linear regression. We will return to this
example repeatedly as we introduce more machine learning concepts that help to
understand its behavior.
As the name implies, linear regression solves a regression problem. In other
words, the goal is to build a system that can take a vector x {\in} Rn as input and
predict the value of a scalar y {\in} R as its output. In the case of linear regression,
the output is a linear function of the input. Let y{\textasciicircum} be the value that our model
predicts y should take on. We define the output to be
y{\textasciicircum} = wx (5.3)
where w {\in} R
n
is a vector of parameters. Parameters are values that control the behavior of the system. In this case, wi is
the coefficient that we multiply by feature xi before summing up the contributions
from all the features. We can think of w as a set of weights that determine how
each feature affects the prediction. If a feature xi receives a positive weight wi,
then increasing the value of that feature increases the value of our prediction y{\textasciicircum}. If a feature receives a negative weight, then increasing the value of that feature
decreases the value of our prediction. If a feature`s weight is large in magnitude,
then it has a large effect on the prediction. If a feature`s weight is zero, it has no
effect on the prediction.
We thus have a definition of our task T : to predict y from x by outputting
y{\textasciicircum} = wx. Next we need a definition of our performance measure, P. Suppose that we have a design matrix of m example inputs that we will not
use for training, only for evaluating how well the model performs. We also have
a vector of regression targets providing the correct value of y for each of these
examples. Because this dataset will only be used for evaluation, we call it the test
set. We refer to the design matrix of inputs as X(test) and the vector of regression
targets as y
(test)
. One way of measuring the performance of the model is to compute the mean
squared error of the model on the test set. If y{\textasciicircum}
(test) gives the predictions of the
model on the test set, then the mean squared error is given by
MSEtest =
1
m 
i
(y{\textasciicircum}
(test) {-} y
(test))
2
i . (5.4)
Intuitively, one can see that this error measure decreases to 0 when y{\textasciicircum}
(test) = y
(test)
. We can also see that
MSEtest =
1
m
||{\textasciicircum}y
(test) {-} y
(test)
||2
2
, (5.5)
so the error increases whenever the Euclidean distance between the predictions
and the targets increases. To make a machine learning algorithm, we need to design an algorithm that
will improve the weights w in a way that reduces MSEtest when the algorithm
is allowed to gain experience by observing a training set (X(train)
, y
(train)). One
intuitive way of doing this (which we will justify later, in section 5.5.1) is just to
minimize the mean squared error on the training set, MSEtrain. To minimize MSEtrain, we can simply solve for where its gradient is 0:
{\nabla}wMSEtrain = 0 (5.6)
{\Rightarrow} {\nabla}w
1
m
||y{\textasciicircum}
(train) {-} y
(train)
||2
2 = 0 (5.7)
{\Rightarrow}
1
m
{\nabla}w||X(train)w {-} y
(train)
||2
2 = 0 (5.8)
{-}1.0 {-}0.5 0.0 0.5 1.0 x1
{-}3
{-}2
{-}1
0
1
2
3
y
Linear regression example
0.5 1.0 1.5 w1
0.20
0.25
0.30
0.35
0.40
0.45
0.50
0.55 MSE(train)
Optimization of w
Figure 5.1: A linear regression problem, with a training set consisting of ten data points, each containing one feature. Because there is only one feature, the weight vector w
contains only a single parameter to learn, w1. (Left)Observe that linear regression learns
to set w1 such that the line y = w1x comes as close as possible to passing through all the
training points. (Right)The plotted point indicates the value of w1 found by the normal
equations, which we can see minimizes the mean squared error on the training set. {\Rightarrow} {\nabla}w
X(train)w {-} y
(train)  X(train)w {-} y
(train) = 0 (5.9)
{\Rightarrow} {\nabla}w
wX(train)X(train)w {-} 2wX(train)y
(train) + y
(train)y
(train) = 0
(5.10)
{\Rightarrow} 2X(train)X(train)w {-} 2X(train) y
(train) = 0 (5.11)
{\Rightarrow} w =
X(train)X(train){-}1
X(train)
y
(train) (5.12)
The system of equations whose solution is given by equation 5.12 is known as
the normal equations. Evaluating equation 5.12 constitutes a simple learning
algorithm. For an example of the linear regression learning algorithm in action,
see figure 5.1.
It is worth noting that the term linear regression is often used to refer to
a slightly more sophisticated model with one additional parameter{\textemdash}an intercept
term b. In this model
y{\textasciicircum} = wx + b (5.13)
so the mapping from parameters to predictions is still a linear function but the
mapping from features to predictions is now an affine function. This extension to
affine functions means that the plot of the model`s predictions still looks like a
line, but it need not pass through the origin. Instead of adding the bias parameter
b, one can continue to use the model with only weights but augment x with an
extra entry that is always set to 1. The weight corresponding to the extra 1 entry
plays the role of the bias parameter. We will frequently use the term {\textquotedblleft}linear{\textquotedblright} when
referring to affine functions throughout this book.
The intercept term b is often called the bias parameter of the affine transformation. This terminology derives from the point of view that the output of the
transformation is biased toward being b in the absence of any input. This term
is different from the idea of a statistical bias, in which a statistical estimation
algorithm`s expected estimate of a quantity is not equal to the true quantity. Linear regression is of course an extremely simple and limited learning algorithm,
but it provides an example of how a learning algorithm can work. In the subsequent
sections we will describe some of the basic principles underlying learning algorithm
design and demonstrate how these principles can be used to build more complicated
learning algorithms.
5.2 Capacity, Overfitting and Underfitting
The central challenge in machine learning is that we must perform well on new, previously unseen inputs{\textemdash}not just those on which our model was trained. The
ability to perform well on previously unobserved inputs is called generalization. Typically, when training a machine learning model, we have access to a training
set, we can compute some error measure on the training set called the training
error, and we reduce this training error. So far, what we have described is simply
an optimization problem. What separates machine learning from optimization is
that we want the generalization error, also called the test error, to be low as
well. The generalization error is defined as the expected value of the error on a
new input. Here the expectation is taken across different possible inputs, drawn
from the distribution of inputs we expect the system to encounter in practice.
We typically estimate the generalization error of a machine learning model by
measuring its performance on a test set of examples that were collected separately
from the training set.
In our linear regression example, we trained the model by minimizing the
training error,
1
m(train)
||X(train)w {-} y
(train)
||2
2
, (5.14)
but we actually care about the test error, 1 m(test) ||X(test)w {-} y
(test)
||2
2
. How can we affect performance on the test set when we get to observe only the
training set? The field of statistical learning theory provides some answers. If
the training and the test set are collected arbitrarily, there is indeed little we can
do. If we are allowed to make some assumptions about how the training and test
set are collected, then we can make some progress. The train and test data are generated by a probability distribution over datasets
called the data generating process. We typically make a set of assumptions
known collectively as the i.i.d. assumptions. These assumptions are that the
examples in each dataset are independent from each other, and that the train
set and test set are identically distributed, drawn from the same probability
distribution as each other. This assumption allows us to describe the data generating process with a probability distribution over a single example. The same
distribution is then used to generate every train example and every test example.
We call that shared underlying distribution the data generating distribution, denoted pdata. This probabilistic framework and the i.i.d. assumptions allow us to
mathematically study the relationship between training error and test error.
One immediate connection we can observe between the training and test error
is that the expected training error of a randomly selected model is equal to the
expected test error of that model. Suppose we have a probability distribution
p(x, y) and we sample from it repeatedly to generate the train set and the test
set. For some fixed value w, the expected training set error is exactly the same as
the expected test set error, because both expectations are formed using the same
dataset sampling process. The only difference between the two conditions is the
name we assign to the dataset we sample.
Of course, when we use a machine learning algorithm, we do not fix the
parameters ahead of time, then sample both datasets. We sample the training set, then use it to choose the parameters to reduce training set error, then sample the
test set. Under this process, the expected test error is greater than or equal to
the expected value of training error. The factors determining how well a machine
learning algorithm will perform are its ability to:
1. Make the training error small.
2. Make the gap between training and test error small.
These two factors correspond to the two central challenges in machine learning:
underfitting and overfitting. Underfitting occurs when the model is not able to
obtain a sufficiently low error value on the training set. Overfitting occurs when
the gap between the training error and test error is too large.
We can control whether a model is more likely to overfit or underfit by altering
its capacity. Informally, a model`s capacity is its ability to fit a wide variety of
functions. Models with low capacity may struggle to fit the training set. Models
with high capacity can overfit by memorizing properties of the training set that do
not serve them well on the test set. One way to control the capacity of a learning algorithm is by choosing its
hypothesis space, the set of functions that the learning algorithm is allowed to
select as being the solution. For example, the linear regression algorithm has the
set of all linear functions of its input as its hypothesis space. We can generalize
linear regression to include polynomials, rather than just linear functions, in its
hypothesis space. Doing so increases the model`s capacity. A polynomial of degree one gives us the linear regression model with which we
are already familiar, with prediction
y{\textasciicircum} = b + wx. (5.15)
By introducing x
2 as another feature provided to the linear regression model, we
can learn a model that is quadratic as a function of x:
y{\textasciicircum} = b + w1x + w2x
2
. (5.16)
Though this model implements a quadratic function of its input, the output is
still a linear function of the parameters, so we can still use the normal equations
to train the model in closed form. We can continue to add more powers of x as
additional features, for example to obtain a polynomial of degree 9:
y{\textasciicircum} = b +
9
i=1
wix
i. (5.17)
Machine learning algorithms will generally perform best when their capacity
is appropriate for the true complexity of the task they need to perform and the
amount of training data they are provided with. Models with insufficient capacity
are unable to solve complex tasks. Models with high capacity can solve complex
tasks, but when their capacity is higher than needed to solve the present task they
may overfit. Figure 5.2 shows this principle in action. We compare a linear, quadratic
and degree-9 predictor attempting to fit a problem where the true underlying
function is quadratic. The linear function is unable to capture the curvature in
the true underlying problem, so it underfits. The degree-9 predictor is capable of
representing the correct function, but it is also capable of representing infinitely
many other functions that pass exactly through the training points, because we
have more parameters than training examples. We have little chance of choosing
a solution that generalizes well when so many wildly different solutions exist. In
this example, the quadratic model is perfectly matched to the true structure of
the task so it generalizes well to new data.





 



Figure 5.2: We fit three models to this example training set. The training data was
generated synthetically, by randomly sampling x values and choosing y deterministically
by evaluating a quadratic function. (Left)A linear function fit to the data suffers from
underfitting{\textemdash}it cannot capture the curvature that is present in the data. (Center)A
quadratic function fit to the data generalizes well to unseen points. It does not suffer from
a significant amount of overfitting or underfitting. (Right)A polynomial of degree 9 fit to
the data suffers from overfitting. Here we used the Moore-Penrose pseudoinverse to solve
the underdetermined normal equations. The solution passes through all of the training
points exactly, but we have not been lucky enough for it to extract the correct structure.
It now has a deep valley in between two training points that does not appear in the true
underlying function. It also increases sharply on the left side of the data, while the true
function decreases in this area.
So far we have described only one way of changing a model`s capacity: by
changing the number of input features it has, and simultaneously adding new
parameters associated with those features. There are in fact many ways of changing
a model`s capacity. Capacity is not determined only by the choice of model. The
model specifies which family of functions the learning algorithm can choose from
when varying the parameters in order to reduce a training objective. This is called
the representational capacity of the model. In many cases, finding the best
function within this family is a very difficult optimization problem. In practice,
the learning algorithm does not actually find the best function, but merely one
that significantly reduces the training error. These additional limitations, such as
the imperfection of the optimization algorithm, mean that the learning algorithm`s
effective capacity may be less than the representational capacity of the model
family. Our modern ideas about improving the generalization of machine learning
models are refinements of thought dating back to philosophers at least as early
as Ptolemy. Many early scholars invoke a principle of parsimony that is now
most widely known as Occam`s razor (c. 1287-1347). This principle states that
among competing hypotheses that explain known observations equally well, one
should choose the {\textquotedblleft}simplest{\textquotedblright} one. This idea was formalized and made more precise
in the 20th century by the founders of statistical learning theory (Vapnik and
Chervonenkis, 1971; Vapnik, 1982; Blumer et al., 1989; Vapnik, 1995). Statistical learning theory provides various means of quantifying model capacity. Among these, the most well-known is the Vapnik-Chervonenkis dimension, or
VC dimension. The VC dimension measures the capacity of a binary classifier. The
VC dimension is defined as being the largest possible value of m for which there
exists a training set of m different x points that the classifier can label arbitrarily. Quantifying the capacity of the model allows statistical learning theory to
make quantitative predictions. The most important results in statistical learning
theory show that the discrepancy between training error and generalization error
is bounded from above by a quantity that grows as the model capacity grows but
shrinks as the number of training examples increases (Vapnik and Chervonenkis, 1971; Vapnik, 1982; Blumer et al., 1989; Vapnik, 1995). These bounds provide
intellectual justification that machine learning algorithms can work, but they are
rarely used in practice when working with deep learning algorithms. This is in
part because the bounds are often quite loose and in part because it can be quite
difficult to determine the capacity of deep learning algorithms. The problem of
determining the capacity of a deep learning model is especially difficult because the
effective capacity is limited by the capabilities of the optimization algorithm, and
we have little theoretical understanding of the very general non-convex optimization
problems involved in deep learning.
We must remember that while simpler functions are more likely to generalize
(to have a small gap between training and test error) we must still choose a
sufficiently complex hypothesis to achieve low training error. Typically, training
error decreases until it asymptotes to the minimum possible error value as model
capacity increases (assuming the error measure has a minimum value). Typically, generalization error has a U-shaped curve as a function of model capacity. This is
illustrated in figure 5.3. To reach the most extreme case of arbitrarily high capacity, we introduce
0 Optimal Capacity
Capacity
Error Underfitting zone Overfitting zone
Generalization gap
Training error
Generalization error
Figure 5.3: Typical relationship between capacity and error. Training and test error
behave differently. At the left end of the graph, training error and generalization error
are both high. This is the underfitting regime. As we increase capacity, training error
decreases, but the gap between training and generalization error increases. Eventually, the size of this gap outweighs the decrease in training error, and we enter the overfitting
regime, where capacity is too large, above the optimal capacity.
the concept of non-parametric models. So far, we have seen only parametric
models, such as linear regression. Parametric models learn a function described
by a parameter vector whose size is finite and fixed before any data is observed.
Non-parametric models have no such limitation.
Sometimes, non-parametric models are just theoretical abstractions (such as
an algorithm that searches over all possible probability distributions) that cannot
be implemented in practice. However, we can also design practical non-parametric
models by making their complexity a function of the training set size. One example
of such an algorithm is nearest neighbor regression. Unlike linear regression,
which has a fixed-length vector of weights, the nearest neighbor regression model
simply stores the X and y from the training set. When asked to classify a test
point x, the model looks up the nearest entry in the training set and returns the
associated regression target. In other words, y{\textasciicircum} = yi where i = arg min ||Xi,: {-} x||2
2
. The algorithm can also be generalized to distance metrics other than the L
2 norm,
such as learned distance metrics (Goldberger et al., 2005). If the algorithm is
allowed to break ties by averaging the yi values for all Xi,: that are tied for nearest, then this algorithm is able to achieve the minimum possible training error (which
might be greater than zero, if two identical inputs are associated with different
outputs) on any regression dataset. Finally, we can also create a non-parametric learning algorithm by wrapping a
parametric learning algorithm inside another algorithm that increases the number
of parameters as needed. For example, we could imagine an outer loop of learning
that changes the degree of the polynomial learned by linear regression on top of a
polynomial expansion of the input.
The ideal model is an oracle that simply knows the true probability distribution
that generates the data. Even such a model will still incur some error on many
problems, because there may still be some noise in the distribution. In the case
of supervised learning, the mapping from x to y may be inherently stochastic,
or y may be a deterministic function that involves other variables besides those
included in x. The error incurred by an oracle making predictions from the true
distribution p(x, y) is called the Bayes error. Training and generalization error vary as the size of the training set varies. Expected generalization error can never increase as the number of training examples
increases. For non-parametric models, more data yields better generalization until
the best possible error is achieved. Any fixed parametric model with less than
optimal capacity will asymptote to an error value that exceeds the Bayes error. See
figure 5.4 for an illustration. Note that it is possible for the model to have optimal
capacity and yet still have a large gap between training and generalization error.
In this situation, we may be able to reduce this gap by gathering more training
examples.
5.2.1 The No Free Lunch Theorem
Learning theory claims that a machine learning algorithm can generalize well from
a finite training set of examples. This seems to contradict some basic principles of
logic. Inductive reasoning, or inferring general rules from a limited set of examples,
is not logically valid. To logically infer a rule describing every member of a set, one must have information about every member of that set.
In part, machine learning avoids this problem by offering only probabilistic rules, rather than the entirely certain rules used in purely logical reasoning. Machine
learning promises to find rules that are probably correct about most members of
the set they concern.
Unfortunately, even this does not resolve the entire problem. The no free
lunch theorem for machine learning (Wolpert, 1996) states that, averaged over
all possible data generating distributions, every classification algorithm has the
same error rate when classifying previously unobserved points. In other words,
in some sense, no machine learning algorithm is universally any better than any
other. The most sophisticated algorithm we can conceive of has the same average

 

Figure 5.4: The effect of the training dataset size on the train and test error, as well as
on the optimal model capacity. We constructed a synthetic regression problem based on
adding a moderate amount of noise to a degree-5 polynomial, generated a single test set, and then generated several different sizes of training set. For each size, we generated 40
different training sets in order to plot error bars showing 95 percent confidence intervals. (Top)The MSE on the training and test set for two different models: a quadratic model,
and a model with degree chosen to minimize the test error. Both are fit in closed form. For
the quadratic model, the training error increases as the size of the training set increases. This is because larger datasets are harder to fit. Simultaneously, the test error decreases, because fewer incorrect hypotheses are consistent with the training data. The quadratic
model does not have enough capacity to solve the task, so its test error asymptotes to
a high value. The test error at optimal capacity asymptotes to the Bayes error. The
training error can fall below the Bayes error, due to the ability of the training algorithm
to memorize specific instances of the training set. As the training size increases to infinity, the training error of any fixed-capacity model (here, the quadratic model) must rise to at
least the Bayes error. (Bottom)As the training set size increases, the optimal capacity
(shown here as the degree of the optimal polynomial regressor) increases. The optimal
capacity plateaus after reaching sufficient complexity to solve the task.

performance (over all possible tasks) as merely predicting that every point belongs
to the same class. Fortunately, these results hold only when we average over all possible data
generating distributions. If we make assumptions about the kinds of probability
distributions we encounter in real-world applications, then we can design learning
algorithms that perform well on these distributions.
This means that the goal of machine learning research is not to seek a universal
learning algorithm or the absolute best learning algorithm. Instead, our goal is to
understand what kinds of distributions are relevant to the {\textquotedblleft}real world{\textquotedblright} that an AI
agent experiences, and what kinds of machine learning algorithms perform well on
data drawn from the kinds of data generating distributions we care about.
5.2.2 Regularization
The no free lunch theorem implies that we must design our machine learning
algorithms to perform well on a specific task. We do so by building a set of
preferences into the learning algorithm. When these preferences are aligned with
the learning problems we ask the algorithm to solve, it performs better. So far, the only method of modifying a learning algorithm that we have discussed
concretely is to increase or decrease the model`s representational capacity by adding
or removing functions from the hypothesis space of solutions the learning algorithm
is able to choose. We gave the specific example of increasing or decreasing the
degree of a polynomial for a regression problem. The view we have described so
far is oversimplified.
The behavior of our algorithm is strongly affected not just by how large we
make the set of functions allowed in its hypothesis space, but by the specific identity
of those functions. The learning algorithm we have studied so far, linear regression,
has a hypothesis space consisting of the set of linear functions of its input. These
linear functions can be very useful for problems where the relationship between
inputs and outputs truly is close to linear. They are less useful for problems
that behave in a very nonlinear fashion. For example, linear regression would
not perform very well if we tried to use it to predict sin(x) from x. We can thus
control the performance of our algorithms by choosing what kind of functions we
allow them to draw solutions from, as well as by controlling the amount of these
functions. We can also give a learning algorithm a preference for one solution in its
hypothesis space to another. This means that both functions are eligible, but one
is preferred. The unpreferred solution will be chosen only if it fits the training
data significantly better than the preferred solution.
For example, we can modify the training criterion for linear regression to include
weight decay. To perform linear regression with weight decay, we minimize a sum
comprising both the mean squared error on the training and a criterion J (w) that
expresses a preference for the weights to have smaller squared L
2 norm. Specifically,
J(w) = MSEtrain + {\lambda}ww, (5.18)
where {\lambda} is a value chosen ahead of time that controls the strength of our preference
for smaller weights. When {\lambda} = 0, we impose no preference, and larger {\lambda} forces the
weights to become smaller. Minimizing J(w) results in a choice of weights that
make a tradeoff between fitting the training data and being small. This gives us
solutions that have a smaller slope, or put weight on fewer of the features. As an
example of how we can control a model`s tendency to overfit or underfit via weight
decay, we can train a high-degree polynomial regression model with different values
of {\lambda}. See figure 5.5 for the results.



 


  
 




Figure 5.5: We fit a high-degree polynomial regression model to our example training set
from figure 5.2. The true function is quadratic, but here we use only models with degree 9.
We vary the amount of weight decay to prevent these high-degree models from overfitting.
(Left)With very large {\lambda}, we can force the model to learn a function with no slope at
all. This underfits because it can only represent a constant function. (Center)With a
medium value of {\lambda}, the learning algorithm recovers a curve with the right general shape.
Even though the model is capable of representing functions with much more complicated
shape, weight decay has encouraged it to use a simpler function described by smaller
coefficients. (Right)With weight decay approaching zero (i.e., using the Moore-Penrose
pseudoinverse to solve the underdetermined problem with minimal regularization), the
degree-9 polynomial overfits significantly, as we saw in figure 5.2.
More generally, we can regularize a model that learns a function f(x; {\theta}) by
adding a penalty called a regularizer to the cost function. In the case of weight
decay, the regularizer is {\Omega}(w) = ww. In chapter 7, we will see that many other
regularizers are possible.
Expressing preferences for one function over another is a more general way
of controlling a model`s capacity than including or excluding members from the
hypothesis space. We can think of excluding a function from a hypothesis space as
expressing an infinitely strong preference against that function.
In our weight decay example, we expressed our preference for linear functions
defined with smaller weights explicitly, via an extra term in the criterion we
minimize. There are many other ways of expressing preferences for different
solutions, both implicitly and explicitly. Together, these different approaches
are known as regularization. Regularization is any modification we make to a
learning algorithm that is intended to reduce its generalization error but not its
training error. Regularization is one of the central concerns of the field of machine
learning, rivaled in its importance only by optimization.
The no free lunch theorem has made it clear that there is no best machine
learning algorithm, and, in particular, no best form of regularization. Instead
we must choose a form of regularization that is well-suited to the particular task
we want to solve. The philosophy of deep learning in general and this book in
particular is that a very wide range of tasks (such as all of the intellectual tasks
that people can do) may all be solved effectively using very general-purpose forms
of regularization.
5.3 Hyperparameters and Validation Sets
Most machine learning algorithms have several settings that we can use to control
the behavior of the learning algorithm. These settings are called hyperparame- ters. The values of hyperparameters are not adapted by the learning algorithm
itself (though we can design a nested learning procedure where one learning
algorithm learns the best hyperparameters for another learning algorithm).
In the polynomial regression example we saw in figure 5.2, there is a single
hyperparameter: the degree of the polynomial, which acts as a capacity hyper- parameter. The {\lambda} value used to control the strength of weight decay is another
example of a hyperparameter.
Sometimes a setting is chosen to be a hyperparameter that the learning algorithm does not learn because it is difficult to optimize. More frequently, the
setting must be a hyperparameter because it is not appropriate to learn that
hyperparameter on the training set. This applies to all hyperparameters that
control model capacity. If learned on the training set, such hyperparameters would
always choose the maximum possible model capacity, resulting in overfitting (refer
to figure 5.3). For example, we can always fit the training set better with a higher
degree polynomial and a weight decay setting of {\lambda} = 0 than we could with a lower
degree polynomial and a positive weight decay setting.
To solve this problem, we need a validation set of examples that the training
algorithm does not observe. Earlier we discussed how a held-out test set, composed of examples coming from
the same distribution as the training set, can be used to estimate the generalization
error of a learner, after the learning process has completed. It is important that the
test examples are not used in any way to make choices about the model, including
its hyperparameters. For this reason, no example from the test set can be used
in the validation set. Therefore, we always construct the validation set from the
training data. Specifically, we split the training data into two disjoint subsets. One
of these subsets is used to learn the parameters. The other subset is our validation
set, used to estimate the generalization error during or after training, allowing
for the hyperparameters to be updated accordingly. The subset of data used to
learn the parameters is still typically called the training set, even though this
may be confused with the larger pool of data used for the entire training process. The subset of data used to guide the selection of hyperparameters is called the
validation set. Typically, one uses about 80{\%} of the training data for training and
20{\%} for validation. Since the validation set is used to {\textquotedblleft}train{\textquotedblright} the hyperparameters, the validation set error will underestimate the generalization error, though typically
by a smaller amount than the training error. After all hyperparameter optimization
is complete, the generalization error may be estimated using the test set.
In practice, when the same test set has been used repeatedly to evaluate
performance of different algorithms over many years, and especially if we consider
all the attempts from the scientific community at beating the reported state-ofthe-art performance on that test set, we end up having optimistic evaluations with
the test set as well. Benchmarks can thus become stale and then do not reflect the
true field performance of a trained system. Thankfully, the community tends to
move on to new (and usually more ambitious and larger) benchmark datasets.


5.3.1 Cross-Validation
Dividing the dataset into a fixed training set and a fixed test set can be problematic
if it results in the test set being small. A small test set implies statistical uncertainty
around the estimated average test error, making it difficult to claim that algorithm
A works better than algorithm B on the given task. When the dataset has hundreds of thousands of examples or more, this is not a
serious issue. When the dataset is too small, are alternative procedures enable one
to use all of the examples in the estimation of the mean test error, at the price of
increased computational cost. These procedures are based on the idea of repeating
the training and testing computation on different randomly chosen subsets or splits
of the original dataset. The most common of these is the k-fold cross-validation
procedure, shown in algorithm 5.1, in which a partition of the dataset is formed by
splitting it into k non-overlapping subsets. The test error may then be estimated
by taking the average test error across k trials. On trial i, the i-th subset of the
data is used as the test set and the rest of the data is used as the training set. One
problem is that there exist no unbiased estimators of the variance of such average
error estimators (Bengio and Grandvalet, 2004), but approximations are typically
used.
5.4 Estimators, Bias and Variance
The field of statistics gives us many tools that can be used to achieve the machine
learning goal of solving a task not only on the training set but also to generalize.
Foundational concepts such as parameter estimation, bias and variance are useful
to formally characterize notions of generalization, underfitting and overfitting.
5.4.1 Point Estimation
Point estimation is the attempt to provide the single {\textquotedblleft}best{\textquotedblright} prediction of some
quantity of interest. In general the quantity of interest can be a single parameter
or a vector of parameters in some parametric model, such as the weights in our
linear regression example in section 5.1.4, but it can also be a whole function.
In order to distinguish estimates of parameters from their true value, our
convention will be to denote a point estimate of a parameter {\theta} by {\theta}{\textasciicircum}. Let {\{}x
(1)
, . . . , x
(m){\}} be a set of m independent and identically distributed


Algorithm 5.1 The k-fold cross-validation algorithm. It can be used to estimate
generalization error of a learning algorithm A when the given dataset D is too
small for a simple train/test or train/valid split to yield accurate estimation of
generalization error, because the mean of a loss L on a small test set may have too
high variance. The dataset D contains as elements the abstract examples z
(i) (for
the i-th example), which could stand for an (input,target) pair z
(i) = (x
(i)
, y
(i))
in the case of supervised learning, or for just an input z
(i) = x
(i)
in the case
of unsupervised learning. The algorithm returns the vector of errors e for each
example in D, whose mean is the estimated generalization error. The errors on
individual examples can be used to compute a confidence interval around the mean
(equation 5.47). While these confidence intervals are not well-justified after the
use of cross-validation, it is still common practice to use them to declare that
algorithm A is better than algorithm B only if the confidence interval of the error
of algorithm A lies below and does not intersect the confidence interval of algorithm
B. Define KFoldXV(D, A,L, k):
Require: D, the given dataset, with elements z
(i)
Require: A, the learning algorithm, seen as a function that takes a dataset as
input and outputs a learned function
Require: L, the loss function, seen as a function from a learned function f and
an example z
(i) {\in} D to a scalar {\in} R
Require: k, the number of folds
Split D into k mutually exclusive subsets Di, whose union is D. for i from 1 to k do
fi = A(D{\textbackslash}Di)
for z
(j)
in Di do
ej = L(fi, z
(j))
end for
end for
Return e
(i.i.d.) data points. A point estimator or statistic is any function of the data:
{\theta}{\textasciicircum}m = g(x
(1)
, . . . , x
(m) ). (5.19)
The definition does not require that g return a value that is close to the true
{\theta} or even that the range of g is the same as the set of allowable values of {\theta}. This definition of a point estimator is very general and allows the designer of an
estimator great flexibility. While almost any function thus qualifies as an estimator, a good estimator is a function whose output is close to the true underlying {\theta} that
generated the training data.
For now, we take the frequentist perspective on statistics. That is, we assume
that the true parameter value {\theta} is fixed but unknown, while the point estimate
{\theta}{\textasciicircum} is a function of the data. Since the data is drawn from a random process, any
function of the data is random. Therefore {\theta}{\textasciicircum} is a random variable.
Point estimation can also refer to the estimation of the relationship between
input and target variables. We refer to these types of point estimates as function
estimators.
Function Estimation As we mentioned above, sometimes we are interested in
performing function estimation (or function approximation). Here we are trying to
predict a variable y given an input vector x. We assume that there is a function
f (x) that describes the approximate relationship between y and x. For example,
we may assume that y = f(x) + , where  stands for the part of y that is not
predictable from x. In function estimation, we are interested in approximating
f with a model or estimate {\textasciicircum}f. Function estimation is really just the same as
estimating a parameter {\theta}; the function estimator {\textasciicircum}f is simply a point estimator in
function space. The linear regression example (discussed above in section 5.1.4) and
the polynomial regression example (discussed in section 5.2) are both examples of
scenarios that may be interpreted either as estimating a parameter w or estimating
a function {\textasciicircum}f mapping from x to y. We now review the most commonly studied properties of point estimators and
discuss what they tell us about these estimators.
5.4.2 Bias
The bias of an estimator is defined as:
bias({\theta}{\textasciicircum}m) = E({\theta}{\textasciicircum}m) {-} {\theta} (5.20)
where the expectation is over the data (seen as samples from a random variable)
and {\theta} is the true underlying value of {\theta} used to define the data generating distribution. An estimator {\theta}{\textasciicircum}m is said to be unbiased if bias({\theta}{\textasciicircum}m) = 0, which implies
that E({\theta}{\textasciicircum}m) = {\theta}. An estimator {\theta}{\textasciicircum}m is said to be asymptotically unbiased if
limm{\textrightarrow}{\infty} bias({\theta}{\textasciicircum}m) = 0, which implies that limm{\textrightarrow}{\infty} E({\theta}{\textasciicircum}m) = {\theta}.
Example: Bernoulli Distribution Consider a set of samples {\{}x
(1)
, . . . , x
(m){\}}
that are independently and identically distributed according to a Bernoulli distribution with mean {\theta}:
P(x
(i)
; {\theta}) = {\theta}
x
(i) (1 {-} {\theta})
(1{-}x
(i))
. (5.21)
A common estimator for the {\theta} parameter of this distribution is the mean of the
training samples: {\textasciicircum}{\theta}m =
1
m m
i=1
x
(i)
. (5.22)
To determine whether this estimator is biased, we can substitute equation 5.22
into equation 5.20:
bias({\textasciicircum}{\theta}m) = E[{\textasciicircum}{\theta}m] {-} {\theta} (5.23) = E

1
m m
i=1
x
(i){-} {\theta} (5.24)
=
1
mm
i=1
E
x
(i) {-} {\theta} (5.25)
=
1
mm
i=1

1
x(i)=0

x
(i){\theta}
x
(i)(1 {-} {\theta})
(1{-}x
(i) ) {-} {\theta} (5.26)
=
1
mm
i=1
({\theta}) {-} {\theta} (5.27) = {\theta} {-} {\theta} = 0 (5.28)
Since bias({\textasciicircum}{\theta}) = 0, we say that our estimator {\textasciicircum}{\theta} is unbiased.
Example: Gaussian Distribution Estimator of the Mean Now, consider
a set of samples {\{}x
(1)
, . . . , x
(m){\}} that are independently and identically distributed
according to a Gaussian distribution p(x
(i)) = N (x
(i)
; {\textmu}, {\sigma}
2 ), where i {\in} {\{}1, . . . , m{\}}.

Recall that the Gaussian probability density function is given by
p(x
(i)
; {\textmu}, {\sigma}
2) =
1
{\sqrt{}}
2{\pi}{\sigma}2
exp 
{-}
1
2
(x
(i) {-} {\textmu})
2
{\sigma}2

. (5.29)
A common estimator of the Gaussian mean parameter is known as the sample
mean:
{\textmu}{\textasciicircum}m =
1
m m
i=1
x
(i) (5.30)
To determine the bias of the sample mean, we are again interested in calculating
its expectation:
bias({\textmu}{\textasciicircum}m) = E[{\textmu}{\textasciicircum}m] {-} {\textmu} (5.31) = E

1
m m
i=1
x
(i) {-} {\textmu} (5.32)
= 
1
m m
i=1
E
x
(i)
{-} {\textmu} (5.33)
= 
1
m m
i=1
{\textmu}
{-} {\textmu} (5.34) = {\textmu} {-} {\textmu} = 0 (5.35)
Thus we find that the sample mean is an unbiased estimator of Gaussian mean
parameter.
Example: Estimators of the Variance of a Gaussian Distribution As an
example, we compare two different estimators of the variance parameter {\sigma}
2 of a
Gaussian distribution. We are interested in knowing if either estimator is biased.
The first estimator of {\sigma}
2 we consider is known as the sample variance:
{\sigma}{\textasciicircum}
2m =
1
mm
i=1

x
(i) {-} {\textmu}{\textasciicircum} m
2
, (5.36)
where {\textmu}{\textasciicircum}m is the sample mean, defined above. More formally, we are interested in
computing
bias({\sigma}{\textasciicircum}
2m) = E[{\sigma}{\textasciicircum}
2m] {-} {\sigma}
2
(5.37)
We begin by evaluating the term E[{\sigma}{\textasciicircum}
2m ]:
E[{\sigma}{\textasciicircum}
2m] =E

1
mm
i=1

x
(i) {-} {\textmu}{\textasciicircum}m
2
(5.38)
=m {-} 1
m
{\sigma}
2
(5.39)
Returning to equation 5.37, we conclude that the bias of {\sigma}{\textasciicircum}
2m is {-}{\sigma}
2/m. Therefore, the sample variance is a biased estimator. The unbiased sample variance estimator
{\sigma}{\textasciitilde}
2m =
1
m {-} 1 m
i=1

x
(i) {-} {\textmu}{\textasciicircum}m
2
(5.40)
provides an alternative approach. As the name suggests this estimator is unbiased.
That is, we find that E[{\sigma}{\textasciitilde}
2m] = {\sigma}
2
:
E[{\sigma}{\textasciitilde}
2m] = E

1
m {-} 1 m
i=1

x
(i) {-} {\textmu}{\textasciicircum}m
2
(5.41) = m
m {-} 1
E[{\sigma}{\textasciicircum}
2m ] (5.42) = m
m {-} 1
m {-} 1
m
{\sigma}
2
(5.43) = {\sigma}
2
. (5.44)
We have two estimators: one is biased and the other is not. While unbiased
estimators are clearly desirable, they are not always the {\textquotedblleft}best{\textquotedblright} estimators. As we
will see we often use biased estimators that possess other important properties.
5.4.3 Variance and Standard Error
Another property of the estimator that we might want to consider is how much
we expect it to vary as a function of the data sample. Just as we computed the
expectation of the estimator to determine its bias, we can compute its variance.
The variance of an estimator is simply the variance
Var( {\textasciicircum}{\theta}) (5.45)
where the random variable is the training set. Alternately, the square root of the
variance is called the standard error, denoted SE({\textasciicircum}{\theta}).
The variance or the standard error of an estimator provides a measure of how
we would expect the estimate we compute from data to vary as we independently
resample the dataset from the underlying data generating process. Just as we
might like an estimator to exhibit low bias we would also like it to have relatively
low variance.
When we compute any statistic using a finite number of samples, our estimate
of the true underlying parameter is uncertain, in the sense that we could have
obtained other samples from the same distribution and their statistics would have
been different. The expected degree of variation in any estimator is a source of
error that we want to quantify. The standard error of the mean is given by
SE({\textmu}{\textasciicircum}m) = 
Var
1
mm
i=1
x
(i) =
{\sigma}
{\sqrt{}}m
, (5.46)
where {\sigma}
2
is the true variance of the samples x
i. The standard error is often
estimated by using an estimate of {\sigma}. Unfortunately, neither the square root of
the sample variance nor the square root of the unbiased estimator of the variance
provide an unbiased estimate of the standard deviation. Both approaches tend
to underestimate the true standard deviation, but are still used in practice. The
square root of the unbiased estimator of the variance is less of an underestimate.
For large m, the approximation is quite reasonable. The standard error of the mean is very useful in machine learning experiments. We often estimate the generalization error by computing the sample mean of the
error on the test set. The number of examples in the test set determines the
accuracy of this estimate. Taking advantage of the central limit theorem, which
tells us that the mean will be approximately distributed with a normal distribution,
we can use the standard error to compute the probability that the true expectation
falls in any chosen interval. For example, the 95{\%} confidence interval centered on
the mean {\textmu}{\textasciicircum}m is
({\textmu}{\textasciicircum}m {-} 1.96SE({\textmu}{\textasciicircum} m), {\textmu}{\textasciicircum}m + 1.96SE({\textmu}{\textasciicircum}m)), (5.47)
under the normal distribution with mean {\textmu}{\textasciicircum}m and variance SE({\textmu}{\textasciicircum}m)
2
. In machine
learning experiments, it is common to say that algorithm A is better than algorithm
B if the upper bound of the 95{\%} confidence interval for the error of algorithm A is
less than the lower bound of the 95{\%} confidence interval for the error of algorithm
B.
Example: Bernoulli Distribution We once again consider a set of samples
{\{}x
(1)
, . . . , x
(m){\}} drawn independently and identically from a Bernoulli distribution
(recall P(x
(i)
; {\theta}) = {\theta}
x
(i)(1 {-} {\theta})
(1{-}x
(i) )). This time we are interested in computing
the variance of the estimator {\textasciicircum}{\theta}m =
1mm
i=1 x
(i)
.
Var
{\textasciicircum}{\theta}m
 = Var 
1
m m
i=1
x
(i)
(5.48)
=
1
m2 m
i=1
Var 
x
(i)
(5.49)
=
1
m2 m
i=1
{\theta}(1 {-} {\theta}) (5.50)
=
1
m2 m{\theta}(1 {-} {\theta}) (5.51) =
1
m
{\theta}(1 {-} {\theta}) (5.52)
The variance of the estimator decreases as a function of m, the number of examples
in the dataset. This is a common property of popular estimators that we will
return to when we discuss consistency (see section 5.4.5).
5.4.4 Trading off Bias and Variance to Minimize Mean Squared
Error
Bias and variance measure two different sources of error in an estimator. Bias
measures the expected deviation from the true value of the function or parameter.
Variance on the other hand, provides a measure of the deviation from the expected
estimator value that any particular sampling of the data is likely to cause. What happens when we are given a choice between two estimators, one with
more bias and one with more variance? How do we choose between them? For
example, imagine that we are interested in approximating the function shown in
figure 5.2 and we are only offered the choice between a model with large bias and
one that suffers from large variance. How do we choose between them?
The most common way to negotiate this trade-off is to use cross-validation.
Empirically, cross-validation is highly successful on many real-world tasks. Alternatively, we can also compare the mean squared error (MSE) of the estimates:
MSE = E[({\textasciicircum}{\theta}m {-} {\theta})
2
] (5.53) = Bias({\textasciicircum}{\theta}m)
2 + Var({\textasciicircum}{\theta}m) (5.54)
The MSE measures the overall expected deviation{\textemdash}in a squared error sense{\textemdash}
between the estimator and the true value of the parameter {\theta}. As is clear from
equation 5.54, evaluating the MSE incorporates both the bias and the variance.
Desirable estimators are those with small MSE and these are estimators that
manage to keep both their bias and variance somewhat in check.
Capacity
Bias Generalization
error Variance
Optimal capacity
Underfitting zone Overfitting zone
Figure 5.6: As capacity increases (x-axis), bias (dotted) tends to decrease and variance
(dashed) tends to increase, yielding another U-shaped curve for generalization error (bold
curve). If we vary capacity along one axis, there is an optimal capacity, with underfitting
when the capacity is below this optimum and overfitting when it is above. This relationship
is similar to the relationship between capacity, underfitting, and overfitting, discussed in
section 5.2 and figure 5.3. The relationship between bias and variance is tightly linked to the machine
learning concepts of capacity, underfitting and overfitting. In the case where generalization error is measured by the MSE (where bias and variance are meaningful
components of generalization error), increasing capacity tends to increase variance
and decrease bias. This is illustrated in figure 5.6, where we see again the U-shaped
curve of generalization error as a function of capacity.
5.4.5 Consistency
So far we have discussed the properties of various estimators for a training set of
fixed size. Usually, we are also concerned with the behavior of an estimator as the
amount of training data grows. In particular, we usually wish that, as the number
of data points m in our dataset increases, our point estimates converge to the true
value of the corresponding parameters. More formally, we would like that
plimm{\textrightarrow}{\infty}
{\textasciicircum}{\theta}m = {\theta}. (5.55)
The symbol plim indicates convergence in probability, meaning that for any  {>} 0, P (|{\textasciicircum}{\theta}m {-} {\theta}| {>} ) {\textrightarrow} 0 as m {\textrightarrow} {\infty}. The condition described by equation 5.55 is
known as consistency. It is sometimes referred to as weak consistency, with
strong consistency referring to the almost sure convergence of {\textasciicircum}{\theta} to {\theta}. Almost
sure convergence of a sequence of random variables x
(1)
, x
(2)
, . . . to a value x
occurs when p(limm{\textrightarrow}{\infty} x
(m) = x) = 1. Consistency ensures that the bias induced by the estimator diminishes as the
number of data examples grows. However, the reverse is not true{\textemdash}asymptotic
unbiasedness does not imply consistency. For example, consider estimating the
mean parameter {\textmu} of a normal distribution N (x; {\textmu}, {\sigma}
2), with a dataset consisting
of m samples: {\{}x
(1)
, . . . , x
(m){\}}. We could use the first sample x
(1) of the dataset
as an unbiased estimator: {\textasciicircum}{\theta} = x
(1)
. In that case, E({\textasciicircum}{\theta}m) = {\theta} so the estimator
is unbiased no matter how many data points are seen. This, of course, implies
that the estimate is asymptotically unbiased. However, this is not a consistent
estimator as it is not the case that {\textasciicircum}{\theta}m {\textrightarrow} {\theta} as m {\textrightarrow} {\infty}.
5.5 Maximum Likelihood Estimation
Previously, we have seen some definitions of common estimators and analyzed
their properties. But where did these estimators come from? Rather than guessing
that some function might make a good estimator and then analyzing its bias and
variance, we would like to have some principle from which we can derive specific
functions that are good estimators for different models. The most common such principle is the maximum likelihood principle.
Consider a set of m examples X = {\{}x
(1)
, . . . , x
(m){\}} drawn independently from
the true but unknown data generating distribution pdata(x). Let pmodel(x;{\theta}) be a parametric family of probability distributions over the
same space indexed by {\theta}. In other words, pmodel(x;{\theta} ) maps any configuration x
to a real number estimating the true probability pdata(x). The maximum likelihood estimator for {\theta} is then defined as
{\theta}ML = arg max
{\theta}
pmodel(X; {\theta}) (5.56)
= arg max
{\theta} m
i=1
pmodel(x
(i)
; {\theta}) (5.57)
This product over many probabilities can be inconvenient for a variety of reasons. For example, it is prone to numerical underflow. To obtain a more convenient
but equivalent optimization problem, we observe that taking the logarithm of the
likelihood does not change its arg max but does conveniently transform a product
into a sum:
{\theta}ML = arg max
{\theta} m
i=1
log pmodel(x
(i)
; {\theta}). (5.58)
Because the arg max does not change when we rescale the cost function, we can
divide by m to obtain a version of the criterion that is expressed as an expectation
with respect to the empirical distribution p{\textasciicircum}data defined by the training data:
{\theta}ML = arg max
{\theta}
Ex{\sim}p{\textasciicircum}data
log pmodel(x; {\theta}). (5.59)
One way to interpret maximum likelihood estimation is to view it as minimizing
the dissimilarity between the empirical distribution p{\textasciicircum}data defined by the training
set and the model distribution, with the degree of dissimilarity between the two
measured by the KL divergence. The KL divergence is given by
DKL (p{\textasciicircum}data pmodel) = Ex{\sim}p{\textasciicircum}data
[log p{\textasciicircum}data (x) {-} log pmodel(x)] . (5.60)
The term on the left is a function only of the data generating process, not the
model. This means when we train the model to minimize the KL divergence, we
need only minimize {-} Ex{\sim}p{\textasciicircum}data
[log pmodel(x)] (5.61)
which is of course the same as the maximization in equation 5.59. Minimizing this KL divergence corresponds exactly to minimizing the cross- entropy between the distributions. Many authors use the term {\textquotedblleft}cross-entropy{\textquotedblright} to
identify specifically the negative log-likelihood of a Bernoulli or softmax distribution,
but that is a misnomer. Any loss consisting of a negative log-likelihood is a cross- entropy between the empirical distribution defined by the training set and the
probability distribution defined by model. For example, mean squared error is the
cross-entropy between the empirical distribution and a Gaussian model.
We can thus see maximum likelihood as an attempt to make the model dis- tribution match the empirical distribution p{\textasciicircum}data. Ideally, we would like to match
the true data generating distribution pdata, but we have no direct access to this
distribution.
While the optimal {\theta} is the same regardless of whether we are maximizing the
likelihood or minimizing the KL divergence, the values of the objective functions
are different. In software, we often phrase both as minimizing a cost function.
Maximum likelihood thus becomes minimization of the negative log-likelihood
(NLL), or equivalently, minimization of the cross entropy. The perspective of
maximum likelihood as minimum KL divergence becomes helpful in this case
because the KL divergence has a known minimum value of zero. The negative
log-likelihood can actually become negative when x is real-valued.
5.5.1 Conditional Log-Likelihood and Mean Squared Error
The maximum likelihood estimator can readily be generalized to the case where
our goal is to estimate a conditional probability P(y | x;{\theta}) in order to predict y
given x. This is actually the most common situation because it forms the basis for
most supervised learning. If X represents all our inputs and Y all our observed
targets, then the conditional maximum likelihood estimator is
{\theta}ML = arg max
{\theta}
P(Y | X; {\theta}). (5.62)
If the examples are assumed to be i.i.d., then this can be decomposed into
{\theta}ML = arg max
{\theta} m
i=1
log P(y
(i)
| x
(i)
; {\theta}). (5.63)
Example: Linear Regression as Maximum Likelihood Linear regression,
introduced earlier in section 5.1.4, may be justified as a maximum likelihood
procedure. Previously, we motivated linear regression as an algorithm that learns
to take an input x and produce an output value y{\textasciicircum}. The mapping from x to y{\textasciicircum} is
chosen to minimize mean squared error, a criterion that we introduced more or less
arbitrarily. We now revisit linear regression from the point of view of maximum
likelihood estimation. Instead of producing a single prediction y{\textasciicircum}, we now think
of the model as producing a conditional distribution p(y | x). We can imagine
that with an infinitely large training set, we might see several training examples
with the same input value x but different values of y. The goal of the learning
algorithm is now to fit the distribution p(y | x) to all of those different y values
that are all compatible with x. To derive the same linear regression algorithm
we obtained before, we define p(y | x) = N (y;y{\textasciicircum}(x; w), {\sigma}
2). The function y{\textasciicircum}(x; w)
gives the prediction of the mean of the Gaussian. In this example, we assume that
the variance is fixed to some constant {\sigma}
2 chosen by the user. We will see that this
choice of the functional form of p(y | x) causes the maximum likelihood estimation
procedure to yield the same learning algorithm as we developed before. Since the
examples are assumed to be i.i.d., the conditional log-likelihood (equation 5.63) is
given by
m
i=1
log p(y
(i)
| x
(i)
; {\theta}) (5.64)
= {-} mlog {\sigma} {-} m
2
log(2{\pi}) {-}m
i=1

y{\textasciicircum}
(i) {-} y
(i)2
2{\sigma}2
, (5.65)
where y{\textasciicircum}
(i)
is the output of the linear regression on the i-th input x
(i) and m is the
number of the training examples. Comparing the log-likelihood with the mean
squared error,
MSEtrain =
1
m m
i=1
||y{\textasciicircum}
(i) {-} y
(i)
||2
, (5.66)
we immediately see that maximizing the log-likelihood with respect to w yields
the same estimate of the parameters w as does minimizing the mean squared error.
The two criteria have different values but the same location of the optimum. This
justifies the use of the MSE as a maximum likelihood estimation procedure. As we
will see, the maximum likelihood estimator has several desirable properties.
5.5.2 Properties of Maximum Likelihood
The main appeal of the maximum likelihood estimator is that it can be shown to
be the best estimator asymptotically, as the number of examples m {\textrightarrow} {\infty}, in terms
of its rate of convergence as m increases. Under appropriate conditions, the maximum likelihood estimator has the
property of consistency (see section 5.4.5 above), meaning that as the number
of training examples approaches infinity, the maximum likelihood estimate of a
parameter converges to the true value of the parameter. These conditions are:
 The true distribution pdata must lie within the model family pmodel({\textperiodcentered}; {\theta}). Otherwise, no estimator can recover pdata .
 The true distribution pdata must correspond to exactly one value of {\theta}. Otherwise, maximum likelihood can recover the correct pdata , but will not be able
to determine which value of {\theta} was used by the data generating processing.
There are other inductive principles besides the maximum likelihood estimator, many of which share the property of being consistent estimators. However,
consistent estimators can differ in their statistic efficiency, meaning that one
consistent estimator may obtain lower generalization error for a fixed number of
samples m, or equivalently, may require fewer examples to obtain a fixed level of
generalization error.
Statistical efficiency is typically studied in the parametric case (like in linear
regression) where our goal is to estimate the value of a parameter (and assuming
it is possible to identify the true parameter), not the value of a function. A way to
measure how close we are to the true parameter is by the expected mean squared
error, computing the squared difference between the estimated and true parameter
values, where the expectation is over m training samples from the data generating
distribution. That parametric mean squared error decreases as m increases, and
for m large, the Cram{\'e}r-Rao lower bound (Rao, 1945; Cram{\'e}r, 1946) shows that no
consistent estimator has a lower mean squared error than the maximum likelihood
estimator. For these reasons (consistency and efficiency), maximum likelihood is often
considered the preferred estimator to use for machine learning. When the number
of examples is small enough to yield overfitting behavior, regularization strategies
such as weight decay may be used to obtain a biased version of maximum likelihood
that has less variance when training data is limited.
5.6 Bayesian Statistics
So far we have discussed frequentist statistics and approaches based on estimating a single value of {\theta}, then making all predictions thereafter based on that one
estimate. Another approach is to consider all possible values of {\theta} when making a
prediction. The latter is the domain of Bayesian statistics. As discussed in section 5.4.1, the frequentist perspective is that the true
parameter value {\theta} is fixed but unknown, while the point estimate {\theta}{\textasciicircum} is a random
variable on account of it being a function of the dataset (which is seen as random).
The Bayesian perspective on statistics is quite different. The Bayesian uses
probability to reflect degrees of certainty of states of knowledge. The dataset is
directly observed and so is not random. On the other hand, the true parameter {\theta}
is unknown or uncertain and thus is represented as a random variable.
Before observing the data, we represent our knowledge of {\theta} using the prior
probability distribution, p({\theta}) (sometimes referred to as simply {\textquotedblleft}the prior{\textquotedblright}).
Generally, the machine learning practitioner selects a prior distribution that is
quite broad (i.e. with high entropy) to reflect a high degree of uncertainty in the
value of {\theta} before observing any data. For example, one might assume a priori that
{\theta} lies in some finite range or volume, with a uniform distribution. Many priors
instead reflect a preference for {\textquotedblleft}simpler{\textquotedblright} solutions (such as smaller magnitude
coefficients, or a function that is closer to being constant). Now consider that we have a set of data samples {\{}x
(1)
, . . . , x
(m) {\}}. We can
recover the effect of data on our belief about {\theta} by combining the data likelihood
p(x
(1)
, . . . , x
(m)
| {\theta}) with the prior via Bayes` rule:
p({\theta} | x
(1)
, . . . , x
(m)) =
p(x
(1)
, . . . , x
(m)
| {\theta})p({\theta})
p(x(1)
, . . . , x(m) )
(5.67)
In the scenarios where Bayesian estimation is typically used, the prior begins as a
relatively uniform or Gaussian distribution with high entropy, and the observation
of the data usually causes the posterior to lose entropy and concentrate around a
few highly likely values of the parameters. Relative to maximum likelihood estimation, Bayesian estimation offers two
important differences. First, unlike the maximum likelihood approach that makes
predictions using a point estimate of {\theta}, the Bayesian approach is to make predictions
using a full distribution over {\theta}. For example, after observing m examples, the
predicted distribution over the next data sample, x
(m+1)
, is given by
p(x
(m+1)
| x
(1)
, . . . , x
(m) ) =

p(x
(m+1)
| {\theta})p({\theta} | x
(1)
, . . . , x
(m) ) d{\theta}. (5.68)
Here each value of {\theta} with positive probability density contributes to the prediction
of the next example, with the contribution weighted by the posterior density itself.
After having observed {\{}x
(1)
, . . . , x
(m){\}}, if we are still quite uncertain about the
value of {\theta}, then this uncertainty is incorporated directly into any predictions we
might make.
In section 5.4, we discussed how the frequentist approach addresses the uncertainty in a given point estimate of {\theta} by evaluating its variance. The variance of
the estimator is an assessment of how the estimate might change with alternative
samplings of the observed data. The Bayesian answer to the question of how to deal
with the uncertainty in the estimator is to simply integrate over it, which tends to
protect well against overfitting. This integral is of course just an application of
the laws of probability, making the Bayesian approach simple to justify, while the
frequentist machinery for constructing an estimator is based on the rather ad hoc
decision to summarize all knowledge contained in the dataset with a single point
estimate.
The second important difference between the Bayesian approach to estimation
and the maximum likelihood approach is due to the contribution of the Bayesian
prior distribution. The prior has an influence by shifting probability mass density
towards regions of the parameter space that are preferred a priori. In practice,
the prior often expresses a preference for models that are simpler or more smooth.
Critics of the Bayesian approach identify the prior as a source of subjective human
judgment impacting the predictions.
Bayesian methods typically generalize much better when limited training data
is available, but typically suffer from high computational cost when the number of
training examples is large.
Example: Bayesian Linear Regression Here we consider the Bayesian estimation approach to learning the linear regression parameters. In linear regression,
we learn a linear mapping from an input vector x {\in} Rn to predict the value of a
scalar y {\in} R. The prediction is parametrized by the vector w {\in} Rn
:
y{\textasciicircum} = wx. (5.69)
Given a set of m training samples (X(train)
, y
(train) ), we can express the prediction
of y over the entire training set as:
y{\textasciicircum}
(train) = X(train)w. (5.70)
Expressed as a Gaussian conditional distribution on y
(train)
, we have
p(y
(train)
| X(train)
, w) = N (y
(train)
; X(train)w, I) (5.71)
{\propto} exp {-}
1
2
(y
(train) {-} X(train)w)
(y
(train) {-} X(train)w)
,
(5.72)
where we follow the standard MSE formulation in assuming that the Gaussian
variance on y is one. In what follows, to reduce the notational burden, we refer to
(X(train)
, y
(train)) as simply (X, y). To determine the posterior distribution over the model parameter vector w, we
first need to specify a prior distribution. The prior should reflect our naive belief
about the value of these parameters. While it is sometimes difficult or unnatural
to express our prior beliefs in terms of the parameters of the model, in practice we
typically assume a fairly broad distribution expressing a high degree of uncertainty
about {\theta}. For real-valued parameters it is common to use a Gaussian as a prior
distribution:
p(w) = N (w; {\textmu}0 , {\Lambda}0) {\propto} exp {-}
1
2
(w {-} {\textmu}0){\Lambda}
{-}1
0 (w {-} {\textmu}0)
, (5.73)
where {\textmu}0 and {\Lambda}0 are the prior distribution mean vector and covariance matrix
respectively.1
With the prior thus specified, we can now proceed in determining the posterior
distribution over the model parameters. p(w | X, y) {\propto} p(y | X, w)p(w) (5.74)
{\propto} exp {-}
1
2
(y {-} Xw) (y {-} Xw)
exp{-}
1
2
(w {-} {\textmu}0){\Lambda}
{-}1
0 (w {-} {\textmu}0)
(5.75)
{\propto} exp {-}
1
2
{-}2yXw + w XXw + w{\Lambda}
{-}1
0 w {-} 2{\textmu}

0 {\Lambda}
{-}1
0 w

.
(5.76)
We now define {\Lambda}m =
XX + {\Lambda}
{-}1
0 {-}1 and {\textmu}m = {\Lambda}m
X y + {\Lambda}
{-}1
0 {\textmu}0 
. Using
these new variables, we find that the posterior may be rewritten as a Gaussian
distribution:
p(w | X, y) {\propto} exp {-}
1
2
(w {-} {\textmu}m) {\Lambda}
{-}1 m (w {-} {\textmu} m) +
1
2{\textmu}
m{\Lambda}
{-}1 m {\textmu}m
(5.77)
{\propto} exp {-}
1
2
(w {-} {\textmu}m) {\Lambda}
{-}1 m (w {-} {\textmu} m)
. (5.78)
All terms that do not include the parameter vector w have been omitted; they
are implied by the fact that the distribution must be normalized to integrate to 1. Equation 3.23 shows how to normalize a multivariate Gaussian distribution.
Examining this posterior distribution allows us to gain some intuition for the
effect of Bayesian inference. In most situations, we set {\textmu}0 to 0. If we set {\Lambda}0 = 1{\alpha}I, then {\textmu}m gives the same estimate of w as does frequentist linear regression with a
weight decay penalty of {\alpha}ww. One difference is that the Bayesian estimate is
undefined if {\alpha} is set to zero{\textemdash}-we are not allowed to begin the Bayesian learning
process with an infinitely wide prior on w. The more important difference is that
the Bayesian estimate provides a covariance matrix, showing how likely all the
different values of w are, rather than providing only the estimate {\textmu}m.
5.6.1 Maximum A Posteriori (MAP) Estimation
While the most principled approach is to make predictions using the full Bayesian
posterior distribution over the parameter {\theta} , it is still often desirable to have a
1 Unless there is a reason to assume a particular covariance structure, we typically assume a
diagonal covariance matrix {\Lambda}0 = diag({\lambda}0).
single point estimate. One common reason for desiring a point estimate is that
most operations involving the Bayesian posterior for most interesting models are
intractable, and a point estimate offers a tractable approximation. Rather than
simply returning to the maximum likelihood estimate, we can still gain some of
the benefit of the Bayesian approach by allowing the prior to influence the choice
of the point estimate. One rational way to do this is to choose the maximum
a posteriori (MAP) point estimate. The MAP estimate chooses the point of
maximal posterior probability (or maximal probability density in the more common
case of continuous {\theta}):
{\theta}MAP = arg max
{\theta}
p({\theta} | x) = arg max
{\theta}
log p(x | {\theta}) + log p({\theta}). (5.79)
We recognize, above on the right hand side, log p(x | {\theta}), i.e. the standard loglikelihood term, and log p({\theta}), corresponding to the prior distribution.
As an example, consider a linear regression model with a Gaussian prior on
the weights w. If this prior is given by N(w;0, 1
{\lambda}I
2), then the log-prior term in
equation 5.79 is proportional to the familiar {\lambda}ww weight decay penalty, plus a
term that does not depend on w and does not affect the learning process. MAP
Bayesian inference with a Gaussian prior on the weights thus corresponds to weight
decay. As with full Bayesian inference, MAP Bayesian inference has the advantage of
leveraging information that is brought by the prior and cannot be found in the
training data. This additional information helps to reduce the variance in the
MAP point estimate (in comparison to the ML estimate). However, it does so at
the price of increased bias. Many regularized estimation strategies, such as maximum likelihood learning
regularized with weight decay, can be interpreted as making the MAP approximation to Bayesian inference. This view applies when the regularization consists of
adding an extra term to the objective function that corresponds to log p({\theta} ). Not
all regularization penalties correspond to MAP Bayesian inference. For example,
some regularizer terms may not be the logarithm of a probability distribution.
Other regularization terms depend on the data, which of course a prior probability
distribution is not allowed to do.
MAP Bayesian inference provides a straightforward way to design complicated
yet interpretable regularization terms. For example, a more complicated penalty
term can be derived by using a mixture of Gaussians, rather than a single Gaussian
distribution, as the prior (Nowlan and Hinton, 1992).







5.7 Supervised Learning Algorithms
Recall from section 5.1.3 that supervised learning algorithms are, roughly speaking,
learning algorithms that learn to associate some input with some output, given a
training set of examples of inputs x and outputs y. In many cases the outputs
y may be difficult to collect automatically and must be provided by a human
{\textquotedblleft}supervisor,{\textquotedblright} but the term still applies even when the training set targets were
collected automatically.
5.7.1 Probabilistic Supervised Learning
Most supervised learning algorithms in this book are based on estimating a
probability distribution p(y | x). We can do this simply by using maximum
likelihood estimation to find the best parameter vector {\theta} for a parametric family
of distributions p(y | x; {\theta}). We have already seen that linear regression corresponds to the family
p(y | x; {\theta}) = N (y; {\theta}x, I). (5.80)
We can generalize linear regression to the classification scenario by defining a
different family of probability distributions. If we have two classes, class 0 and
class 1, then we need only specify the probability of one of these classes. The
probability of class 1 determines the probability of class 0, because these two values
must add up to 1.
The normal distribution over real-valued numbers that we used for linear
regression is parametrized in terms of a mean. Any value we supply for this mean
is valid. A distribution over a binary variable is slightly more complicated, because
its mean must always be between 0 and 1. One way to solve this problem is to use
the logistic sigmoid function to squash the output of the linear function into the
interval (0, 1) and interpret that value as a probability:
p(y = 1 | x; {\theta}) = {\sigma}({\theta}x). (5.81)
This approach is known as logistic regression (a somewhat strange name since
we use the model for classification rather than regression).
In the case of linear regression, we were able to find the optimal weights by
solving the normal equations. Logistic regression is somewhat more difficult. There
is no closed-form solution for its optimal weights. Instead, we must search for
them by maximizing the log-likelihood. We can do this by minimizing the negative
log-likelihood (NLL) using gradient descent.
This same strategy can be applied to essentially any supervised learning problem,
by writing down a parametric family of conditional probability distributions over
the right kind of input and output variables.
5.7.2 Support Vector Machines
One of the most influential approaches to supervised learning is the support vector
machine (Boser et al., 1992; Cortes and Vapnik, 1995). This model is similar to
logistic regression in that it is driven by a linear function wx + b. Unlike logistic
regression, the support vector machine does not provide probabilities, but only
outputs a class identity. The SVM predicts that the positive class is present when
w x + b is positive. Likewise, it predicts that the negative class is present when
w x + b is negative.
One key innovation associated with support vector machines is the kernel
trick. The kernel trick consists of observing that many machine learning algorithms
can be written exclusively in terms of dot products between examples. For example,
it can be shown that the linear function used by the support vector machine can
be re-written as
w
x + b = b +m
i=1
{\alpha}ix
x
(i) (5.82)
where x
(i)
is a training example and {\alpha} is a vector of coefficients. Rewriting the
learning algorithm this way allows us to replace x by the output of a given feature
function {\varphi}(x) and the dot product with a function k(x, x
(i)) = {\varphi}(x){\textperiodcentered}{\varphi}(x
(i) ) called
a kernel. The {\textperiodcentered} operator represents an inner product analogous to {\varphi}(x){\varphi}(x
(i)). For some feature spaces, we may not use literally the vector inner product. In
some infinite dimensional spaces, we need to use other kinds of inner products, for
example, inner products based on integration rather than summation. A complete
development of these kinds of inner products is beyond the scope of this book.
After replacing dot products with kernel evaluations, we can make predictions
using the function
f(x) = b + 
i
{\alpha}ik(x, x
(i) ). (5.83)
This function is nonlinear with respect to x, but the relationship between {\varphi}(x)
and f (x) is linear. Also, the relationship between {\alpha} and f(x) is linear. The
kernel-based function is exactly equivalent to preprocessing the data by applying
{\varphi}(x) to all inputs, then learning a linear model in the new transformed space.
The kernel trick is powerful for two reasons. First, it allows us to learn models
that are nonlinear as a function of x using convex optimization techniques that are
guaranteed to converge efficiently. This is possible because we consider {\varphi} fixed and
optimize only {\alpha}, i.e., the optimization algorithm can view the decision function
as being linear in a different space. Second, the kernel function k often admits
an implementation that is significantly more computational efficient than naively
constructing two {\varphi}(x) vectors and explicitly taking their dot product.
In some cases, {\varphi}(x) can even be infinite dimensional, which would result in
an infinite computational cost for the naive, explicit approach. In many cases, k(x, x
) is a nonlinear, tractable function of x even when {\varphi}(x) is intractable. As
an example of an infinite-dimensional feature space with a tractable kernel, we
construct a feature mapping {\varphi}(x) over the non-negative integers x. Suppose that
this mapping returns a vector containing x ones followed by infinitely many zeros. We can write a kernel function k(x, x
(i)) = min(x, x
(i)) that is exactly equivalent
to the corresponding infinite-dimensional dot product.
The most commonly used kernel is the Gaussian kernel
k(u, v) = N (u {-} v; 0, {\sigma}
2I) (5.84)
where N(x; {\textmu}, {\Sigma}) is the standard normal density. This kernel is also known as
the radial basis function (RBF) kernel, because its value decreases along lines
in v space radiating outward from u. The Gaussian kernel corresponds to a dot
product in an infinite-dimensional space, but the derivation of this space is less
straightforward than in our example of the min kernel over the integers. We can think of the Gaussian kernel as performing a kind of template matching. A training example x associated with training label y becomes a template
for class y. When a test point x
 is near x according to Euclidean distance, the
Gaussian kernel has a large response, indicating that x
 is very similar to the x
template. The model then puts a large weight on the associated training label y. Overall, the prediction will combine many such training labels weighted by the
similarity of the corresponding training examples. Support vector machines are not the only algorithm that can be enhanced
using the kernel trick. Many other linear models can be enhanced in this way. The
category of algorithms that employ the kernel trick is known as kernel machines
or kernel methods (Williams and Rasmussen, 1996; Sch{\"o}lkopf et al., 1999). A major drawback to kernel machines is that the cost of evaluating the decision
function is linear in the number of training examples, because the i-th example
contributes a term {\alpha}ik(x, x
(i)) to the decision function. Support vector machines
are able to mitigate this by learning an {\alpha} vector that contains mostly zeros. Classifying a new example then requires evaluating the kernel function only for
the training examples that have non-zero {\alpha}i. These training examples are known
as support vectors. Kernel machines also suffer from a high computational cost of training when
the dataset is large. We will revisit this idea in section 5.9. Kernel machines with
generic kernels struggle to generalize well. We will explain why in section 5.11. The
modern incarnation of deep learning was designed to overcome these limitations of
kernel machines. The current deep learning renaissance began when Hinton et al. (2006) demonstrated that a neural network could outperform the RBF kernel SVM
on the MNIST benchmark